---
title: 'execStream'
description: 'Execute a command and stream output in real-time'
---

Executes a shell command and streams the output as it's produced. Returns an async iterable of execution events.

## Method Signature

```typescript
sandbox.execStream(
  command: string,
  options?: StreamOptions
): AsyncIterable<ExecEvent>
```

## Parameters

<ParamField path="command" type="string" required>
  Shell command to execute. Runs in a bash shell with full shell features.
</ParamField>

<ParamField path="options" type="StreamOptions">
  Execution options

  <Expandable title="StreamOptions">
    <ParamField path="timeout" type="number">
      Maximum execution time in milliseconds
    </ParamField>

    <ParamField path="env" type="Record<string, string>">
      Environment variables for this command
    </ParamField>

    <ParamField path="cwd" type="string">
      Working directory for the command
    </ParamField>

    <ParamField path="sessionId" type="string">
      Session ID to execute in
    </ParamField>
  </Expandable>
</ParamField>

## Returns

<ResponseField name="AsyncIterable<ExecEvent>" type="async iterable">
  An async iterable that yields execution events as they occur

  <Expandable title="ExecEvent types">
    <ResponseField name="type: 'stdout'" type="object">
      Standard output chunk
      - `text`: string - Output text
    </ResponseField>

    <ResponseField name="type: 'stderr'" type="object">
      Standard error chunk
      - `text`: string - Error text
    </ResponseField>

    <ResponseField name="type: 'exit'" type="object">
      Command completion
      - `exitCode`: number - Exit code
    </ResponseField>
  </Expandable>
</ResponseField>

## Examples

### Stream command output

```typescript
for await (const event of sandbox.execStream('npm install')) {
  if (event.type === 'stdout') {
    console.log('[OUT]', event.text);
  } else if (event.type === 'stderr') {
    console.error('[ERR]', event.text);
  } else if (event.type === 'exit') {
    console.log('Exit code:', event.exitCode);
  }
}
```

### Stream long-running build

```typescript
const events = sandbox.execStream('npm run build');

for await (const event of events) {
  if (event.type === 'stdout') {
    // Send build progress to client
    await sendProgressUpdate(event.text);
  }
}
```

### Collect all output

```typescript
let stdout = '';
let stderr = '';

for await (const event of sandbox.execStream('python script.py')) {
  if (event.type === 'stdout') stdout += event.text;
  if (event.type === 'stderr') stderr += event.text;
}

console.log('Full output:', stdout);
```

### Stream with timeout

```typescript
try {
  for await (const event of sandbox.execStream('long-task', { 
    timeout: 60000 
  })) {
    console.log(event);
  }
} catch (error) {
  console.error('Command timed out');
}
```

### Stream to HTTP response

```typescript
export default {
  async fetch(request: Request, env: Env) {
    const sandbox = getSandbox(env.Sandbox, 'my-sandbox');
    
    const stream = new ReadableStream({
      async start(controller) {
        for await (const event of sandbox.execStream('tail -f log.txt')) {
          if (event.type === 'stdout') {
            controller.enqueue(new TextEncoder().encode(event.text));
          }
        }
        controller.close();
      }
    });

    return new Response(stream, {
      headers: { 'Content-Type': 'text/plain' }
    });
  }
};
```

## Use Cases

- Build pipelines with progress updates
- Log tailing and monitoring
- Long-running data processing
- Real-time command output in UI
- Streaming responses to clients

## Related Methods

- [exec](/api/exec) - Execute and wait for completion
- [execInteractive](/api/exec-interactive) - Interactive execution with PTY
- [startProcess](/api/start-process) - Background process with log streaming
